# Write a program to count the occurrences of words in a large text file using multiple threads to process different parts of the file concurrently. [Very High]

```java

import java.io.*;
import java.util.*;
import java.util.concurrent.*;

public class WordCountMultiThread {
    // Worker class to process part of the file
    static class WordCountTask implements Callable<Map<String, Integer>> {
        private final List<String> lines;

        public WordCountTask(List<String> lines) {
            this.lines = lines;
        }

        @Override
        public Map<String, Integer> call() {
            Map<String, Integer> localCount = new HashMap<>();
            for (String line : lines) {
                String[] words = line.toLowerCase().split("\\W+"); // split by non-word characters
                for (String word : words) {
                    if (!word.isEmpty()) {
                        localCount.put(word, localCount.getOrDefault(word, 0) + 1);
                    }
                }
            }
            return localCount;
        }
    }

    public static void main(String[] args) {
        // Change the path to a large file on your system
        String filePath = "large_text.txt";

        // Thread pool with 4 worker threads
        ExecutorService executor = Executors.newFixedThreadPool(4);

        List<Future<Map<String, Integer>>> futures = new ArrayList<>();

        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
            List<String> chunk = new ArrayList<>();
            String line;
            int batchSize = 1000; // number of lines per task

            while ((line = br.readLine()) != null) {
                chunk.add(line);
                if (chunk.size() >= batchSize) {
                    // Submit chunk for processing
                    futures.add(executor.submit(new WordCountTask(new ArrayList<>(chunk))));
                    chunk.clear();
                }
            }

            // Submit remaining lines if any
            if (!chunk.isEmpty()) {
                futures.add(executor.submit(new WordCountTask(chunk)));
            }

            // Final word count map
            Map<String, Integer> finalCount = new HashMap<>();

            // Merge results from all threads
            for (Future<Map<String, Integer>> future : futures) {
                Map<String, Integer> localMap = future.get();
                for (Map.Entry<String, Integer> entry : localMap.entrySet()) {
                    finalCount.put(entry.getKey(),
                            finalCount.getOrDefault(entry.getKey(), 0) + entry.getValue());
                }
            }

            // Print top 10 most frequent words
            finalCount.entrySet().stream()
                    .sorted((a, b) -> b.getValue().compareTo(a.getValue()))
                    .limit(10)
                    .forEach(e -> System.out.println(e.getKey() + " -> " + e.getValue()));

        } catch (IOException | InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}


```

## How it Works:

- Reads file in chunks → 1000 lines at a time.

- Each chunk is processed by a Callable task → produces a partial Map<String,Integer>.

- ExecutorService runs tasks concurrently.

- Results merged into a final word frequency map.

- Prints top 10 most frequent words.

## Output:

```java

the -> 5231
and -> 4320
to -> 4012
of -> 3920
a -> 3755
in -> 3204
is -> 2897
that -> 2750
for -> 2630
it -> 2503

```
