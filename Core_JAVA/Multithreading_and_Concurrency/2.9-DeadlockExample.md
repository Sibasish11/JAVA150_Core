# Explain the concept of deadlocks in multithreading and provide a simple code example that could lead to a deadlock. [High]

```java

DEADLOCK IN MULTITHREADING

Definition:

A deadlock occurs in multithreading when two or more threads are blocked forever,
each waiting for the other to release a resource.

Conditions for Deadlock (Coffmanâ€™s conditions):

1. Mutual Exclusion  â€“ Only one thread can use a resource at a time.
2. Hold and Wait     â€“ A thread holds one resource while waiting for another.
3. No Preemption     â€“ Resources cannot be forcibly taken away.
4. Circular Wait     â€“ A cycle exists where each thread waits for a resource
                       held by the next thread in the cycle.

Example scenario:

- Thread 1 locks Resource A, then waits for Resource B.
- Thread 2 locks Resource B, then waits for Resource A.
Neither can continue â†’ Deadlock.

```
```java

class Resource {
    private final String name;
    public Resource(String name) { this.name = name; }
    public String getName() { return name; }
}

public class DeadlockExample {

    public static void main(String[] args) {
        final Resource resource1 = new Resource("Resource1");
        final Resource resource2 = new Resource("Resource2");

        // Thread 1 tries to lock resource1 then resource2
        Thread t1 = new Thread(() -> {
            synchronized (resource1) {
                System.out.println("Thread 1: locked " + resource1.getName());
                try { Thread.sleep(100); } catch (InterruptedException e) {}

                synchronized (resource2) {
                    System.out.println("Thread 1: locked " + resource2.getName());
                }
            }
        });

        // Thread 2 tries to lock resource2 then resource1
        Thread t2 = new Thread(() -> {
            synchronized (resource2) {
                System.out.println("Thread 2: locked " + resource2.getName());
                try { Thread.sleep(100); } catch (InterruptedException e) {}

                synchronized (resource1) {
                    System.out.println("Thread 2: locked " + resource1.getName());
                }
            }
        });

        t1.start();
        t2.start();
    }
}

```

```
EXPECTED BEHAVIOR:
- Both threads may run into deadlock:
  Thread 1 locks Resource1 and waits for Resource2.
  Thread 2 locks Resource2 and waits for Resource1.
- Since neither releases its first lock, both threads are stuck forever.

ðŸ‘‰ Output before deadlock (example):
Thread 1: locked Resource1
Thread 2: locked Resource2
... then both hang (deadlock occurs).

HOW TO AVOID DEADLOCK?

1. Always lock resources in a consistent order.
   (e.g., always lock Resource1 before Resource2 in all threads).
2. Use tryLock() with timeout (from java.util.concurrent.locks.Lock).
3. Minimize the scope of synchronized blocks.




```
