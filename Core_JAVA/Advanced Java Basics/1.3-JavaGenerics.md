# Explain the concept of type erasure in Java Generics. (Conceptual, in comments). [High]

## 🔹 Concept:
- Java implements generics using a technique called **Type Erasure**.
- This means that generic type information is **removed ("erased")** at compile-time.
- The compiler enforces type safety during compilation, but after compilation, all generic
  types are replaced by their raw types (like Object or upper bounds).
- As a result, at runtime, the JVM does not know about generic type parameters.

## 🔹 Example of Erasure:
    List<String> list1 = new ArrayList<>();
    List<Integer> list2 = new ArrayList<>();

  - At runtime, both become just `List`.
  - The type parameter (`String`, `Integer`) is erased.

## 🔹 Why Type Erasure?
- Backward compatibility with older Java versions (before Java 5).
- Generics were added without breaking existing non-generic code.

## 🔹 Consequences of Type Erasure:

1. **No runtime type information**:
     - Cannot check generic type with `instanceof`
       Example: if (list instanceof List<String>) → ❌ Compile Error.
       Only `list instanceof List` works.

2. **No primitive types in generics**:
     - You cannot use `List<int>`; must use `List<Integer>` because generics rely on Objects.

3. **Overloading issues**:
     - Cannot overload methods that differ only by generic parameter.
       Example:
         void print(List<String> list) { }
         void print(List<Integer> list) { } 
       ❌ Compile Error (both look like void print(List) after erasure).

4. **Type casting may be required**:
     - After erasure, compiler inserts casts where necessary.

## 🔹 Example Code:

```java

    List<String> strings = new ArrayList<>();
    strings.add("Java");

    // After type erasure, internally behaves like:
    List list = new ArrayList();
    list.add("Java");   // compiler inserts cast when retrieving

    String s = strings.get(0); // compiler ensures safe cast to String


```
