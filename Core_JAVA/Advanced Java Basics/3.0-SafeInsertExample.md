# Write a program using JDBC prepared statements to prevent SQL injection vulnerabilities when inserting data. [High]

## üîπ Problem:
   - Using string concatenation in SQL can be dangerous.
   - Example (vulnerable):
        Statement stmt = conn.createStatement();
        stmt.execute("INSERT INTO Students(name, age) VALUES ('" + userInput + "', " + age + ")");

   - If userInput = "Robert'); DROP TABLE Students; --"
     üëâ It could delete the whole table!

### üîπ Solution:
   - Use PreparedStatement with placeholders (?) to bind values safely.
   - Prevents SQL injection because input is treated as data, not SQL code.

```java

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class SafeInsertExample {
    public static void main(String[] args) {
        // Database connection URL (SQLite for demo)
        String url = "jdbc:sqlite:test.db";

        // SQL Insert query with placeholders
        String sql = "INSERT INTO Students(name, age) VALUES(?, ?)";

        try (Connection conn = DriverManager.getConnection(url);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            // Example safe inputs
            String name = "Robert'); DROP TABLE Students; --";  // malicious attempt
            int age = 25;

            // Safely bind values (avoids SQL injection)
            pstmt.setString(1, name);
            pstmt.setInt(2, age);

            int rowsInserted = pstmt.executeUpdate();

            if (rowsInserted > 0) {
                System.out.println("‚úÖ Data inserted safely without SQL injection risk.");
            }

        } catch (SQLException e) {
            System.out.println("‚ùå Error inserting data.");
            e.printStackTrace();
        }
    }
}

```

## ‚úÖ Output Example:

Even though the input looks like a SQL attack:

```vbnet

Robert'); DROP TABLE Students; --

```
